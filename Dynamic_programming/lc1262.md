# 1262. Greatest Sum Divisible by Three
### Medium

Given an array nums of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three.

**Example:**

```
Input: nums = [3,6,5,1,8]
Output: 18
Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).
```

**思路：**
这道题可以用数学方法做或者DP方法做。

如果用数学方法，难点在于快速提取三个要点：
1. 最后的结果肯定只会在整个数组里删去一个数。
2. 任意一个数 %3结果只会是0，1，2。
3. 两个 %3=1的数之和%3=2，两个 %3=2的数之和%3=1。
由1和2可以确定大方向就是loop数组并一直更新 %3=1和 %3=2的最小数，最后整个数组的和 %3=1就删掉哪个 %3=1的最小数。余2同理。
而第3条是要处理 min1 = 10，min2 = 5，此时loop到值为2的元素，除了更新 min2 = 2以外，还要更新 min1 = (5+2) = 7。 更准确的说，需要先更新 min1 = min(min1, min2+num)，之后再update min2： min2 = min(min2, num)。

如果用DP方法，难点在于要快速反应DP的状态有三个 %3 = 0, 1, 2。因此用{0:max_sum0, 1:max_sum1, 2:max_sum2}来记录就很合适。
此外，最开始的dict只能init成{0:0}，不能init成{0:0, 1:0, 2:0}。 因为在loop数组之前是没办法确定里面是不是每种余数组合都有，所以 1:0, 2:0可能根本就不会出现。DP解法可以推广到K的情况。

**Code:**
```python
class Solution(object):
    def maxSumDivThree(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # DP SOLUTION
        dict_ = {0:0} # should not init 1 and 2 because new_k is generated by the original keys
        
        for n in nums:
            # update each key, val in dict_
            for k, v in dict_.items():
                new_k = (k + n)%3
                dict_[new_k] = max(v+n, dict_.get(new_k, 0))
        
        return dict_[0]
        
        # MATH SOLUTION
        # min1: min n which %3 = 1, min2: min n which %3 = 2
        # min1 = min2 = 10000
        # sum_ = 0
        # for n in nums:
        #     if n%3 == 1:
        #         min2 = min(min1+n, min2)
        #         min1 = min(min1, n)
        #     elif n%3 == 2:
        #         min1 = min(min2+n, min1)
        #         min2 = min(min2, n)
        #     sum_ +=n
        # if sum_%3 == 1:
        #     return sum_ - min1
        # if sum_%3 == 2:
        #     return sum_ - min2
        # return sum_
```
